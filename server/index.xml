<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Server-rsses on COMP312 labs</title>
    <link>http://philiplei.github.io/server/index.xml</link>
    <description>Recent content in Server-rsses on COMP312 labs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Jun 2016 10:14:43 +0800</lastBuildDate>
    <atom:link href="http://philiplei.github.io/server/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Server-side programming</title>
      <link>http://philiplei.github.io/server/</link>
      <pubDate>Thu, 30 Jun 2016 10:14:43 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/</guid>
      <description>

&lt;h2 id=&#34;server-side-programming&#34;&gt;Server-side programming&lt;/h2&gt;

&lt;p&gt;This chapter goes through the basics of the JavaScript programming on the server side using Node.js.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4-1. Node primer

&lt;ul&gt;
&lt;li&gt;compare node.js and browser env&lt;/li&gt;
&lt;li&gt;install, run *.js&lt;/li&gt;
&lt;li&gt;require module&lt;/li&gt;
&lt;li&gt;event loop. timer&lt;/li&gt;
&lt;li&gt;built-in modules&lt;/li&gt;
&lt;li&gt;file I/O. fs.readFile, fs.writeFile. callback: (err, result) =&amp;gt; { }&lt;/li&gt;
&lt;li&gt;how to manage control flow. sequential.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-2. NPM modules

&lt;ul&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;module request&lt;/li&gt;
&lt;li&gt;sending GET and POST.&lt;/li&gt;
&lt;li&gt;options object pattern&lt;/li&gt;
&lt;li&gt;Node app. package.json. npm install. npm install module &amp;ndash;save&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-3. Routing in web app

&lt;ul&gt;
&lt;li&gt;defining routes, generating response&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-4. Middleware in web app

&lt;ul&gt;
&lt;li&gt;middlewares&lt;/li&gt;
&lt;li&gt;serving static web assets&lt;/li&gt;
&lt;li&gt;process form submit with GET and POST&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-5. Template in web app

&lt;ul&gt;
&lt;li&gt;handlebars&lt;/li&gt;
&lt;li&gt;template files&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-6. Database access

&lt;ul&gt;
&lt;li&gt;sqlite. SELECT, INSERT, UPDATE, DELETE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4-7. classic web app&lt;/li&gt;
&lt;/ul&gt;

&lt;!--

- 4-8. async: flow control?
- advanced
  - promise?
  - stream?

plan:

- app example with several routes, res.sendFile, `res.send(\`&lt;html&gt;multiline&lt;/html&gt;\`)`,
  res.send json, res.status code.
- Middleware
- app example to check req.url, method, route.method. headers? query, post body
- template. use timetable JSON data
- mysql

A condensed view of this chap

- execution model on Node: asynchronous, event loop
- module. NPM community. (writing module)
- writing web client
- writing web app: express, route, middleware, template, req -&gt; res
- milestone: classic web app

--&gt;
</description>
    </item>
    
    <item>
      <title>4-1 Node.js primer</title>
      <link>http://philiplei.github.io/server/4-1/</link>
      <pubDate>Thu, 30 Jun 2016 10:36:44 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-1/</guid>
      <description>

&lt;p&gt;This lab goes through the basics of the Node.js platform.&lt;/p&gt;

&lt;h2 id=&#34;quick-start&#34;&gt;Quick start&lt;/h2&gt;

&lt;p&gt;Node.js &lt;a href=&#34;https://nodejs.org&#34;&gt;(https://nodejs.org)&lt;/a&gt; is a platform built on Chrome&amp;rsquo;s JavaScript runtime V8 for easily building fast, scalable network applications. Node.js supports the same basic JavaScript programming language as web browsers. As the first example, let&amp;rsquo;s run the following program &lt;a href=&#34;http://philiplei.github.io/chap4-1/p101.js&#34;&gt;p101.js&lt;/a&gt; in both browser and Node. (Follow instruction to install Node.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p101.js

// return the largest number in an array
// assume at least 1 entry, and all entries are numbers
function largest (A) {
  var big=A[0];
  for (var i=1; i&amp;lt;A.length; i++) {
    if (big&amp;lt;A[i]) big=A[i];
  }
  return big;
}

var N = [ 3, 7, 6, 8, 2, 5 ];

console.log(&#39;The largest is %d&#39;, largest(N));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The JavaScript engine provides some common features in both Node and browsers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript language features: control flow, variables, data structure, defining class, functions, regular expression, etc&lt;/li&gt;
&lt;li&gt;Some global objects and functions:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;console.log()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;timers: &lt;code&gt;setInterval()&lt;/code&gt;, &lt;code&gt;setTimeout()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Date class: &lt;code&gt;var now = new Date()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JSON processing: &lt;code&gt;JSON.parse()&lt;/code&gt;, &lt;code&gt;JSON.stringify()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But Node misses some features specific to the browser platform, e.g.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;document tree (i.e. DOM tree)

&lt;ul&gt;
&lt;li&gt;a Node program generally does not involve an HTML document&lt;/li&gt;
&lt;li&gt;no interface and mouse or keyboard events&lt;/li&gt;
&lt;li&gt;usually we don&amp;rsquo;t use jQuery&amp;rsquo;s &lt;code&gt;$( )&lt;/code&gt; in Node&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AJAX

&lt;ul&gt;
&lt;li&gt;but there are other objects for network operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;and other APIs in the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Reference/API&#34;&gt;Web API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;event-loop-in-node&#34;&gt;Event loop in Node&lt;/h2&gt;

&lt;p&gt;Similar to JavaScript runtime in browser, Node includes an &lt;strong&gt;event loop&lt;/strong&gt; that handles events.
The event loop continues until all events are handled and there are no future events. Some common cases that trigger events are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;timer: when time is up, call a functions&lt;/li&gt;
&lt;li&gt;file I/O, network I/O, etc: When some data is ready to read, or some I/O operations finish, the Node runtime triggers an event and call an event handler&lt;/li&gt;
&lt;li&gt;some objects can generate events&lt;/li&gt;
&lt;li&gt;system events, e.g. Ctrl-C interrupt&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trace the execution of the following program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p102.js

var N = 10; // countdown from 10
var timer;  // id of the timer

function tick() {
  if (N&amp;lt;=0) {
    console.log(&amp;quot;Time&#39;s up!&amp;quot;);
    clearInterval(timer);
  } else {
    console.log(N); N--;
  }
}

// this starts the timer
timer = setInterval(tick, 1000);

// event loop runs here ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At any time, Node runs at most 1 event handler. If there are no pending events, the event loop blocks and waits for any future events.  If Node determines that there are no more future events, it quits.&lt;/p&gt;

&lt;h2 id=&#34;modules&#34;&gt;Modules&lt;/h2&gt;

&lt;p&gt;An important feature of Node is &lt;strong&gt;modules&lt;/strong&gt;, which allows you to import new functionalities to the Node platform. The Node platform comes with some built-in modules (which are installed together with Node).  See the &lt;a href=&#34;https://nodejs.org/en/docs/&#34;&gt;online reference&lt;/a&gt; for a list of the built-in modules.&lt;/p&gt;

&lt;p&gt;To use a module, import it with &lt;code&gt;require()&lt;/code&gt;. This function returns an object that represents the module in your program. You can assign this to a variable of any convenient name.&lt;/p&gt;

&lt;p&gt;(You can use the REPL tool &lt;a href=&#34;http://mancy-re.pl/&#34;&gt;Mancy&lt;/a&gt; for experiment in this part.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var url = require(&#39;url&#39;);
var a = url.parse(&#39;http://example.com/path/file.js?a=2#hash1&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You can also download modules from the Web and install in the Node platform. We&amp;rsquo;ll come to that later in this chapter.)&lt;/p&gt;

&lt;p&gt;The following example demonstrates how to use another built-in module &lt;code&gt;os&lt;/code&gt; and the built-in class &lt;code&gt;Date&lt;/code&gt; to monitor the amount of free memory. &lt;a href=&#34;https://nodejs.org/dist/latest-v6.x/docs/api/os.html#os_os_freemem&#34;&gt;(online reference)&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p103.js
// show amount of free memory every second
var os = require(&#39;os&#39;);

function tick() {
  var now = new Date();
  var time = now.toTimeString().substring(0,8);
  var fm = os.freemem() / 1024;
  console.log(`${time} - ${fm}k`);
}

console.log(&#39;Start monitoring free memory. Ctrl-C to quit.&#39;)
setInterval(tick, 1000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;evented-i-o&#34;&gt;Evented I/O&lt;/h2&gt;

&lt;p&gt;Node.js has only 1 thread to run JavaScript code. If this thread blocks to wait for I/O completion, the whole Node process is blocked and cannot process other events. Consider the following example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var fs = require(&#39;fs&#39;);
// this function blocks.
// if other event fires while Node is waiting
// for the file read operation to finish,
// the event loop CANNOT run the event handlers.
var data = fs.readFileSync(&#39;intro.txt&#39;, &#39;utf8&#39; );
console.log(&#39;File content: &#39;, data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fs.readFileSync()&lt;/code&gt; and &lt;code&gt;fs.writeFileSync()&lt;/code&gt; are two of the few synchronous I/O functions in Node. They blocks the single thread of Node while waiting for the input / output to finish.&lt;/p&gt;

&lt;p&gt;In other platforms like Java, one usually needs to create multiple &lt;strong&gt;threads&lt;/strong&gt; to handle several I/O operations at the same time (e.g. a web server handling multiple clients). Node uses &lt;strong&gt;evented I/O&lt;/strong&gt; to allow more than one I/O at the same time.  At the time you start an I/O operation, you also need to provide a &lt;strong&gt;callback&lt;/strong&gt; function.  After I/O is done, the event loop will call the callback function and pass either an error, or the result of the I/O.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var fs = require(&#39;fs&#39;);

fs.readFile(&#39;intro.txt&#39;, &#39;utf8&#39;, (err, data)=&amp;gt;{
  // if there is error, handle it, or throw it to quit
  if (err) throw err;
  // no error, the I/O result is &#39;data&#39;
  console.log(&#39;File content: &#39;, data);
} );

// at this point, file read is still in progress
// ...

// event loop waits for I/O to finish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, the third parameter is the callback function. &lt;code&gt;fs.readFile&lt;/code&gt; returns immediately without blocking. However, the I/O result is not available yet.&lt;/p&gt;

&lt;p&gt;Here is a summary of simple asynchronous file I/O operations in the module &lt;code&gt;fs&lt;/code&gt;. Refer to the &lt;a href=&#34;https://nodejs.org/dist/latest-v6.x/docs/api/fs.html&#34;&gt;online reference of module fs&lt;/a&gt; for detail.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.readFile(filename, options, callback)&lt;/code&gt; - read content from the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.writeFile(filename, content, options, callback)&lt;/code&gt; - write the given content to the file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.appendFile(filename, content, options, callback)&lt;/code&gt; - append the given content to the end of the file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In Node, many asynchronous I/O operations have a callback parameter. These operations generate an once-off event when the I/O completes (with data or error).
Usually, the first parameter of the callback is an error object. Since the callback is run by the event loop (and not by any other functions), throwing an error inside the callback will quit the process.&lt;/p&gt;

&lt;h2 id=&#34;sequential-i-o-operations&#34;&gt;Sequential I/O operations&lt;/h2&gt;

&lt;p&gt;Consider the following longer example.  We&amp;rsquo;d like to replace the word &amp;lsquo;MPI&amp;rsquo; by &amp;lsquo;IPM&amp;rsquo; in the input file &amp;lsquo;intro.txt&amp;rsquo;. To ensure that &lt;code&gt;writeFile&lt;/code&gt; is done &lt;strong&gt;after&lt;/strong&gt; &lt;code&gt;readFile&lt;/code&gt; returns data, call &lt;code&gt;writeFile&lt;/code&gt; in the callback for &lt;code&gt;readFile&lt;/code&gt;.&lt;/p&gt;

&lt;!--
The first version uses synchronous I/O. (Notice that this is just for illustration. In most Node application, you should use asynchronous I/O to allow better performance.) In this program, while Node is waiting for I/O completion, it **cannot** process any other events.

```JavaScript
// p104.js
// synchronous version of read file, process and write file.
var fs = require(&#39;fs&#39;);

var data = fs.readFileSync(&#39;intro.txt&#39;, &#39;utf8&#39; );
var newdata = data.replace(/MPI/g, &#39;IPM&#39;);
fs.writeFileSync(&#39;change.txt&#39;, newdata, &#39;utf8&#39;);
```

The preferred method to write the same program is to use asynchronous I/O.
--&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p105.js
// asynchronous version of read file, process, and write file
var fs = require(&#39;fs&#39;);

fs.readFile(&#39;intro.txt&#39;, &#39;utf8&#39;, (err, data)=&amp;gt;{
  if (err) throw err;
  // at this moment, file read is done
  var newdata = data.replace(/MPI/g, &#39;IPM&#39;);
  // we can start file write now
  fs.writeFile(&#39;change.txt&#39;, newdata, &#39;utf8&#39;, (err)=&amp;gt;{
    if (err) throw err;
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, doing some I/O operations in sequence would involve nesting callback functions. The result is sometimes known as &lt;strong&gt;callback hell&lt;/strong&gt; in the Node community.  You can sometimes reduce callback nesting by moving the callback to top level functions.  The following rewrite of the above program demonstrates this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p105.js rewrite: move callback to top level functions
var fs = require(&#39;fs&#39;);

function writeDone (err) {
  if (err) throw err;
}

function readDone (err, data) {
  if (err) throw err;
  var newdata = data.replace(/MPI/g, &#39;IPM&#39;);
  fs.writeFile(&#39;change.txt&#39;, newdata, &#39;utf8&#39;, writeDone);
}

fs.readFile(&#39;intro.txt&#39;, &#39;utf8&#39;, readDone);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Write a program to combine two text file &amp;lsquo;in1.txt&amp;rsquo; and &amp;lsquo;in2.txt&amp;rsquo; to an output text file &amp;lsquo;out.txt&amp;rsquo;.
Use asynchronous I/O functions &lt;code&gt;fs.readFile()&lt;/code&gt; and &lt;code&gt;fs.writeFile()&lt;/code&gt;. (solution: &lt;a href=&#34;http://philiplei.github.io/chap4-1/p106.js&#34;&gt;p106.js&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write a program to monitor the amount of available memory to a log file &amp;lsquo;freemem.txt&amp;rsquo;. Hints: use &lt;code&gt;fs.appendFile()&lt;/code&gt; to append log message to the txt file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- example: read a json, do sth, write output  --&gt;
</description>
    </item>
    
    <item>
      <title>4-2 NPM modules</title>
      <link>http://philiplei.github.io/server/4-2/</link>
      <pubDate>Mon, 25 Jul 2016 10:05:01 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-2/</guid>
      <description>

&lt;p&gt;In this lab, we will&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;install module with &lt;code&gt;npm install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;demonstrate how send HTTP requests using the &lt;code&gt;request&lt;/code&gt; modules.&lt;/li&gt;
&lt;li&gt;cover the concept of a Node app and dependency management in package.json&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;installing-modules&#34;&gt;Installing Modules&lt;/h2&gt;

&lt;p&gt;Node.js has a built-in module called &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt; for making HTTP clients and servers. They are efficient implementation of the HTTP protocol. However, the modules are low-level and not convenient to use. Therefore, the Node community has developed several modules for writing HTTP clients and servers. These modules are published in &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;https://www.npmjs.com/&lt;/a&gt;. A popular choice for HTTP clients is the &lt;code&gt;request&lt;/code&gt; module. &lt;a href=&#34;https://www.npmjs.com/package/request&#34;&gt;(online reference)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;using-request-to-get-an-url&#34;&gt;Using Request to GET an URL&lt;/h2&gt;

&lt;p&gt;The following example fetches the current weather report from &lt;a href=&#34;http://rss.smg.gov.mo/e_ActualWeather_rss.xml&#34;&gt;http://rss.smg.gov.mo/e_ActualWeather_rss.xml&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p301.js
var request = require(&#39;request&#39;);

var url = &#39;http://rss.smg.gov.mo/e_ActualWeather_rss.xml&#39;;
request.get(url, (err, res, body) =&amp;gt; {
  console.log(&#39;STATUS: &#39; + res.statusCode);
  console.log(&#39;HEADERS: &#39;);
  console.dir(res.headers);
  console.log(body);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to run this program, you have to put the program in a project folder. Change the current directory to the project folder, then install the module with the command &lt;code&gt;npm install request&lt;/code&gt;. (Note: the installation is also done once.) You&amp;rsquo;ll see that the command &lt;code&gt;npm&lt;/code&gt; installs the module in a local folder called &lt;code&gt;node_modules&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install request
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The callback for &lt;code&gt;request.get&lt;/code&gt; takes three parameters. The first is the error object. The second is an object of class &lt;code&gt;http.IncomingMessage&lt;/code&gt; &lt;a href=&#34;https://nodejs.org/api/http.html#http_class_http_incomingmessage&#34;&gt;(online reference)&lt;/a&gt;. It represents the HTTP response message. You can use it to check HTTP status code and headers. The last parameter is the message body of the HTTP response.&lt;/p&gt;

&lt;h2 id=&#34;options-object-pattern&#34;&gt;Options object pattern&lt;/h2&gt;

&lt;p&gt;The next example downloads an image from IPM website and saves it.&lt;/p&gt;

&lt;p&gt;The JavaScript programming language does not support named parameters.  Some APIs make use of a pattern caled &lt;strong&gt;options object pattern&lt;/strong&gt; to pass named parameters to a function. For example, if you need to give more information about the HTTP request in addition to URL, you can group these information in an option object and pass it as the first parameter of &lt;code&gt;reqeust.get()&lt;/code&gt;. Refer to online reference for &lt;a href=&#34;https://www.npmjs.com/package/request#requestoptions-callback&#34;&gt;all available options&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p302.js
// - Download and save an image file from www.ipm.edu.mo

var fs = require(&#39;fs&#39;);
var request = require(&#39;request&#39;);

// options object pattern
// use a JS object to group named parameters
// encoding = null is required to get binary data
var options = {
  url: &#39;http://www.ipm.edu.mo/cntfiles/upload/images/common/campus/campusmap_btn_chi_un_img.jpg&#39;,
  encoding: null
};

request.get(options, (err, res, body) =&amp;gt; {
  if (err) throw err;
  if (res.statusCode!==200) {
    console.log(&#39;HTTP status not ok. code = &#39;, res.statusCode);
    return;
  }
  console.log(&#39;HTTP request is successful. Saving file...&#39;);
  fs.writeFile(&#39;campus.jpg&#39;, body, (err) =&amp;gt; {
    if (err) throw err;
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-post-request&#34;&gt;Making POST request&lt;/h2&gt;

&lt;p&gt;In the next example, we want to download the class time table from the IPM web app at
&lt;a href=&#34;https://wapps.ipm.edu.mo/siweb/time_prog.asp&#34;&gt;https://wapps.ipm.edu.mo/siweb/time_prog.asp&lt;/a&gt;.
The web app uses HTTPS (instead of plain HTTP) and the POST method to send query to the server.
The query data can be sent using the &lt;code&gt;form&lt;/code&gt; property in the &lt;code&gt;options&lt;/code&gt; object in &lt;code&gt;request.post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// p303.js
// - saves the response of a POST request to the file timetab.html

var request = require(&#39;request&#39;);
var fs = require(&#39;fs&#39;);

var form = {
  p_escl_cod: 5, /* ... */
  p_year_sem: &#39;2015/2016-1&#39;,
  p_sp_year: 3,
  p_class_code: &#39;31121&#39;
};

var options = {
  url: &#39;https://wapps.ipm.edu.mo/siweb/time_prog.asp&#39;,
  form: form
};

request.post(options, (err, res, body) =&amp;gt; {
  if (err) throw err;
  console.log(&#39;HTTP status: &#39; + res.statusCode);
  // write the HTML response body to an HTML file
  fs.writeFile(&#39;timetab.html&#39;, body, &#39;utf8&#39;, (err)=&amp;gt; {} );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;node-app-and-package-json&#34;&gt;Node app and package.json&lt;/h2&gt;

&lt;p&gt;As an Node application makes use of more NPM modules, it becomes difficult to install the modules manually with the command &lt;code&gt;npm install module-name&lt;/code&gt;. Instead, you can describe the dependencies of a Node app in a JSON txt file called &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can create a &lt;code&gt;package.json&lt;/code&gt; file for a Node app by running this command in the project folder.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Node app contains 1 or more JavaScript file (&lt;code&gt;*.js&lt;/code&gt;) together with modules and other assets (e.g. HTML files, images). All these file are put in a folder. A special file &lt;code&gt;package.json&lt;/code&gt; describes the app. It defines the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt;, which identifies the app in the &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;www.npmjs.com&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;comp312-examples&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Examples of web client&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;private&amp;quot;: true,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;request&amp;quot;: &amp;quot;^2.75&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The config file above indicates that our app depends on the &amp;lsquo;request&amp;rsquo; module. It requires a version &lt;em&gt;compatible&lt;/em&gt; with 2.75.  For more detail about the version specification, refer to the &lt;a href=&#34;https://docs.npmjs.com/getting-started/semantic-versioning&#34;&gt;online document for Semver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After listing all the required modules for the current app in &lt;code&gt;package.json&lt;/code&gt;, you can install all the dependencies with the command &lt;code&gt;npm install&lt;/code&gt;. If later, you need to add a dependency (e.g. &lt;code&gt;cheerio&lt;/code&gt; module), run the following command.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install cheerio --save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command installs the latest version of specified module. In addition, it updates &lt;code&gt;package.json&lt;/code&gt; and adds the module to the dependencies.  Try the command and check the change in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4-3 Routing in web apps</title>
      <link>http://philiplei.github.io/server/4-3/</link>
      <pubDate>Wed, 27 Jul 2016 10:29:04 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-3/</guid>
      <description>

&lt;p&gt;Express.js &lt;a href=&#34;http://expressjs.com/&#34;&gt;(official website)&lt;/a&gt; is a web framework to simplify development of Web applications. It supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Routing – different request processing based on URL patterns&lt;/li&gt;
&lt;li&gt;Middleware – chainable processing of requests and responses&lt;/li&gt;
&lt;li&gt;Template – generate HTML output from variables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This lab covers how to define routes to capture HTTP requests for a web app / service endpoints. In addition, we&amp;rsquo;ll discuss how to generate simple HTTP responses.&lt;/p&gt;

&lt;h2 id=&#34;routes&#34;&gt;Routes&lt;/h2&gt;

&lt;p&gt;This example shows the basic structure of an Express app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var express = require(&#39;express&#39;);
// create an Express application, which will handle HTTP requests
var app = express();

// a route in the app, which handles GET request for the path &#39;/&#39;
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(&#39;hello world&#39;);
});

// more routes ...

// start listening at TCP port 3000
app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a web app receives an HTTP request, it has to decide how to handle the request, and return the result as an HTTP response.  Such decision usually depends on the HTTP method (either GET or POST in most cases) and the path in the URL (e.g. &amp;ldquo;/about.html&amp;rdquo;).   The combination of HTTP method and the URL path is usually referred to as an &lt;strong&gt;endpoint&lt;/strong&gt; of the web app or web service.&lt;/p&gt;

&lt;p&gt;In an Express app, we define a &lt;strong&gt;route&lt;/strong&gt; to describe how to process HTTP requests at an endpoint.
The general syntax is &lt;code&gt;app.get(path, callback)&lt;/code&gt; and &lt;code&gt;app.post(path, callback)&lt;/code&gt;. The callback can take 2 or more parameters.  Often, we only use the first two parameters called &lt;code&gt;req&lt;/code&gt; and &lt;code&gt;res&lt;/code&gt;: &lt;code&gt;req&lt;/code&gt; refers to the incoming HTTP request, and &lt;code&gt;res&lt;/code&gt; is an object that is used to build the HTTP response. The following is a route for GET request at URL &amp;lsquo;/about.html&amp;rsquo;. The route returns a text response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// app is an Express app

app.get(&#39;/about.html&#39;, (req, res) =&amp;gt; {
  // When the Express app receives a GET request
  // for the path &#39;/about.html&#39;, it returns a text response
  res.send(&#39;This is a simple example of route&#39;)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some web apps include parameters in the URL path. For example, the URL &lt;a href=&#34;https://www.google.com/maps/place/Macao+Polytechnic+Institute/&#34;&gt;https://www.google.com/maps/place/Macao+Polytechnic+Institute/&lt;/a&gt; refers to the place &amp;lsquo;Macao Polytechnic Institute&amp;rsquo; in the Google Maps web app.  You can easily extract these parameters in Express routes.&lt;/p&gt;

&lt;p&gt;Consider the sample code below, which shows a web app to check lecture hours. When the app receives a GET request for the path &amp;lsquo;/lecture/comp312&amp;rsquo;, it returns a response of its lecture hours. The parameters are available in the object &lt;code&gt;req.params&lt;/code&gt;. (The full source is &lt;a href=&#34;http://philiplei.github.io/chap4-3/app1.js&#34;&gt;app1.js&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// retrieve the lecture time
app.get(&#39;/lecture/:code&#39;, (req, res) =&amp;gt; {
  // in a real app, we&#39;d query a database ...
  if (req.params.code==&#39;comp312&#39;) {
    res.send(&#39;Tue, Thu: 10:00-11:30am&#39;)
  } else if (req.params.code==&#39;comp311&#39;) {
    // ...
  }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above only describes the basics of routing in Express. Refer to the &lt;a href=&#34;http://expressjs.com/en/guide/routing.html&#34;&gt;online guide&lt;/a&gt; for more possibilities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The order of routes is significant!&lt;/strong&gt;  An Express app checks the routes in the order they are defined. When a route matches the HTTP methods and URL path, the Express app executes its callback function to handle the request.  The callback usually returns an HTTP response with &lt;code&gt;res.send()&lt;/code&gt; or similar methods. When a response is returned, the Express app will &lt;strong&gt;stop&lt;/strong&gt; checking the remaining routes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;app.get(&#39;/lecture/comp312&#39;, (req, res) =&amp;gt; {
  // special response for comp312
  res.send(&#39;...&#39;);
});

// retrieve the lecture time
app.get(&#39;/lecture/:code&#39;, (req, res) =&amp;gt; {
  // search database, return a response
  res.send(&#39;...&#39;);
});

app.get(&#39;/lecture/comp113&#39;, (req, res) =&amp;gt; {
  // special response for comp113. But sorry, this route never runs!
  res.send(&#39;...&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-responses&#34;&gt;Making responses&lt;/h2&gt;

&lt;p&gt;You can use the &lt;code&gt;res&lt;/code&gt; object in the route callback to build a response. &lt;a href=&#34;http://expressjs.com/en/4x/api.html#res&#34;&gt;(online reference)&lt;/a&gt; The &lt;code&gt;res&lt;/code&gt; object has several common methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;res.send(body)&lt;/code&gt; sends a response with the specified body. The body is usually a string, but it can also be JavaScript objects or others.  The method determines the suitable MIME type.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.sendFile(path)&lt;/code&gt; returns a file as response.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.status(code)&lt;/code&gt; sets the HTTP response code. This function is chainable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.redirect(path)&lt;/code&gt; redirects to the given URL.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Check the source code of &lt;a href=&#34;http://philiplei.github.io/chap4-3/app2.js&#34;&gt;app2.js&lt;/a&gt; for demonstration of how to build responses with these methods.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4-4 Middleware in web apps</title>
      <link>http://philiplei.github.io/server/4-4/</link>
      <pubDate>Tue, 09 Aug 2016 15:10:00 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-4/</guid>
      <description>

&lt;p&gt;This lab demonstrates how to use middleware in general. It introduces a few common middleware, and also covers a middleware that handles form submit using GET and POST.&lt;/p&gt;

&lt;h2 id=&#34;middlewares&#34;&gt;Middlewares&lt;/h2&gt;

&lt;p&gt;In the previous lab, we saw that an Express app is essentially a sequence of routes.  When a request arrives at an Express app, the app tries to find a match of the path in the order of routes in the sequence.  If there is a match, the app assumes the callback of the route will generate a response, and skip any remaining routes.&lt;/p&gt;

&lt;p&gt;The above notion is simplification. An Express app is in fact a sequence of middlewares and routes. An incoming request will go through the middlewares and routes in sequential order until a response is generated.&lt;/p&gt;

&lt;p&gt;Middlewares are JavaScript functions in Express. Most middlewares are not included in Express module, and must be installed using &lt;code&gt;npm install&lt;/code&gt; or &lt;code&gt;package.json&lt;/code&gt; separately.  Install the middlewares and Express with &lt;code&gt;npm install&lt;/code&gt; before running the example &lt;a href=&#34;http://philiplei.github.io/chap4-4/app3.js&#34;&gt;app3.js&lt;/a&gt;, which demonstrate the
basic structure of an Express app with middlewares.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// app3.js
// middlewares

var express = require(&#39;express&#39;);
var app = express();

// import a middleware, which logs the request
var morgan = require(&#39;morgan&#39;);
// install the middleware into the app
app.use(morgan(&#39;short&#39;));

// import another middleware, which secures the app with HTTP headers
var helmet = require(&#39;helmet&#39;);
// install the middleware
app.use(helmet());

// routes ...

app.get(&#39;/&#39;, (req, res) =&amp;gt; {
  res.send(&#39;Hello world&#39;);
});

app.get(&#39;*&#39;, (req, res) =&amp;gt; {
  res.status(404).send(&#39;No match&#39;);
});

// start listening at TCP port 3000
app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the app receives an HTTP request, the first middleware &amp;lsquo;morgan&amp;rsquo; prints a log message in the console. Next, the middleware &amp;lsquo;helmet&amp;rsquo; adds some HTTP headers (e.g. &lt;code&gt;X-XSS-Protection&lt;/code&gt;) to the response to secure the app. Afterwards, the request is checked against each route in sequence.&lt;/p&gt;

&lt;p&gt;Most middlewares should be registered &lt;em&gt;before routes&lt;/em&gt;. If a middleware is registered after a route, and the route returns a response for a request, the middleware will NOT run for this request. As an experiment, move the middleware &amp;lsquo;morgan&amp;rsquo; between the two routes.&lt;/p&gt;

&lt;h2 id=&#34;serving-static-content&#34;&gt;Serving static content&lt;/h2&gt;

&lt;p&gt;There is a special middleware bundled with Express. This middleware &lt;code&gt;express-session&lt;/code&gt; serves static assets (typically HTML, CSS, images, and client-side library) to clients. The middleware tries to match the files in a folder against the URL path of the request. If there is a match, it returns the file, with a suitable MIME-type, in a response. This makes it simple to creates a simplistic HTTP server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// excerpt from app4.js
var express = require(&#39;express&#39;);
var app = express();

app.use(express.static(__dirname + &#39;/public&#39;));

app.listen(3000, () =&amp;gt; {
  console.log(&#39;Server running at http://localhost:3000/&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, routes should be placed before the &amp;lsquo;static&amp;rsquo; middleware. Otherwise, a static file that matches the URL path will be handled by the &amp;lsquo;static&amp;rsquo; middleware and will not be handled by any routes after the middleware.  Try to move the specified route in &lt;a href=&#34;http://philiplei.github.io/chap4-4/app4.js&#34;&gt;app4.js&lt;/a&gt; to experiment.&lt;/p&gt;

&lt;h2 id=&#34;handling-form-submit&#34;&gt;Handling form submit&lt;/h2&gt;

&lt;p&gt;Data that are submitted using GET method are available in the object &lt;code&gt;req.query&lt;/code&gt;. In the following example, the route GET &amp;lsquo;/add&amp;rsquo; obtains the two numbers &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from a GET request, and returns the result of &amp;lsquo;a+b&amp;rsquo; in response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// app5.js

var express = require(&#39;express&#39;);
var app = express();

app.get(&#39;/form1.html&#39;, (req, res) =&amp;gt; {
  res.send(`&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;Enter 2 numbers to add:&amp;lt;/p&amp;gt;
  &amp;lt;form action=&#39;/add&#39; method=&#39;GET&#39;&amp;gt;
    &amp;lt;p&amp;gt;a: &amp;lt;input name=&#39;a&#39; type=&#39;text&#39;/&amp;gt;
    &amp;lt;p&amp;gt;b: &amp;lt;input name=&#39;b&#39; type=&#39;text&#39;/&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;button type=&#39;submit&#39;&amp;gt;Calculate a+b&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;`);
});

app.get(&#39;/add&#39;, (req, res) =&amp;gt; {
  var a = parseFloat(req.query.a);
  var b = parseFloat(req.query.b);
  res.send(`${a} + ${b} = ${a+b}`);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll need a middleware to extract data from the message body of a POST request. A popular choice is the middleware &lt;code&gt;body-parser&lt;/code&gt;. This middleware parses the request message body (if any) and populate the object &lt;code&gt;req.body&lt;/code&gt;. In the route in the sample code below (see full source at &lt;a href=&#34;http://philiplei.github.io/chap4-4/app6.js&#34;&gt;app6.js&lt;/a&gt;), data submitted in POST request are accessible in &lt;code&gt;req.body.mesg&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// excerpt from app6.js

var bodyParser = require(&#39;body-parser&#39;);
app.use(bodyParser.urlencoded({extended:false}));

app.post(&#39;/append&#39;, (req, res) =&amp;gt; {
  var mesg = req.body.mesg;
  fs.appendFile(__dirname+&#39;/log.txt&#39;, mesg+&#39;\n&#39;, &#39;utf8&#39;, (err)=&amp;gt;{
    if (err) throw err;
    res.send(`Append successful.
      You can &amp;lt;a href=&amp;quot;/getlog&amp;quot;&amp;gt;retrieve the log&amp;lt;/a&amp;gt; now.`);
  })
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>4-5 Template in web app</title>
      <link>http://philiplei.github.io/server/4-5/</link>
      <pubDate>Wed, 10 Aug 2016 16:21:00 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-5/</guid>
      <description>

&lt;p&gt;This lab demonstrates how to use templates in Express app.&lt;/p&gt;

&lt;p&gt;modules&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll end this part with the implementation of a classic web app. (i.e. before AJAX).&lt;/p&gt;

&lt;h2 id=&#34;template-engine&#34;&gt;Template engine&lt;/h2&gt;

&lt;p&gt;In previous lab, we embedded HTML template inside JavaScript code to render data. This approach becomes impractical when the HTML code or the data become more complicated.  A better approach is to use some template system to render data in the server side.&lt;/p&gt;

&lt;p&gt;We studied how to use the Handlebars template system in &lt;a href=&#34;http://philiplei.github.io/client/3-6&#34;&gt;Lab 3-6&lt;/a&gt; for client-side. It is also possible to use the template system in an Express app with a suitable template engine. A popular module is &lt;code&gt;hbs&lt;/code&gt;.  Install in with the command &lt;code&gt;npm install hbs --save&lt;/code&gt; or &lt;code&gt;npm install&lt;/code&gt; with suitable entry in &lt;code&gt;package.json&lt;/code&gt;. Then, in the Express app, load the engine with the following line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// curiously, you don&#39;t load with ..
// var hbs = require(&#39;hbs&#39;);

// set the template engine to handlebars
app.set(&#39;view engine&#39;, &#39;hbs&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, Express searches for templates in the folder &lt;code&gt;/views&lt;/code&gt; and assume the file extension &lt;code&gt;.hbs&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;app.get(&#39;/year/:y&#39;, (req, res) =&amp;gt; {
  var year = parseInt(req.params.y);
  var coursesInTheYear = timetab.courses.filter((c)=&amp;gt;c.year==year);
  var context = {
    year: year,
    acadYear: timetab.acadYear,
    semester: timetab.semester,
    courses: coursesInTheYear
  };
  // use the template &#39;/views/list.hbs&#39; to render the context object
  res.render(&#39;list&#39;, context);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;file-modules&#34;&gt;File modules&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4-6 Database access</title>
      <link>http://philiplei.github.io/server/4-6/</link>
      <pubDate>Wed, 10 Aug 2016 09:14:00 +0800</pubDate>
      
      <guid>http://philiplei.github.io/server/4-6/</guid>
      <description>

&lt;p&gt;This lab demonstrates how to use a file-based database &lt;code&gt;sqlite&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sqlite&#34;&gt;SQLite&lt;/h2&gt;

&lt;p&gt;SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine (from &lt;a href=&#34;https://www.sqlite.org/&#34;&gt;https://www.sqlite.org/&lt;/a&gt;).
The whole database is stored in a file, and an application can open this database directly without connecting to any server.&lt;/p&gt;

&lt;p&gt;A popular module to access SQLite in Node is &lt;code&gt;sqlite3&lt;/code&gt;. Install this module and update &lt;code&gt;package.json&lt;/code&gt; with the command &lt;code&gt;npm install sqlite3 --save&lt;/code&gt;.  Then create and initialize the sample database &lt;code&gt;todo.sqlite&lt;/code&gt; with the program &lt;code&gt;node init.js&lt;/code&gt;. That program runs the following SQL scripts to create a table and populate it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SQL&#34;&gt;DROP TABLE IF EXISTS `task`;
CREATE TABLE IF NOT EXISTS `task` (
  `id` INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
  `due` TEXT NOT NULL,
  `what` TEXT NOT NULL,
  `category` TEXT NOT NULL,
  `done` INTEGER NOT NULL
);

INSERT INTO `task` (`due`, `what`, `category`, `done`) VALUES
  (&#39;2016-10-27&#39;, &#39;COMP312 Test 1&#39;, &#39;study&#39;, 0),
  (&#39;2016-10-28&#39;, &#39;Project presentation&#39;, &#39;study&#39;, 0),
  (&#39;2016-10-29&#39;, &#39;Buy bday gift&#39;, &#39;home&#39;, 1),
  (&#39;2016-10-31&#39;, &#39;Mary&#39;&#39;s birthday&#39;, &#39;home&#39;, 0),
  (&#39;2016-10-31&#39;, &#39;COMP312 HW 2&#39;, &#39;study&#39;, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;retrieve-data-with-select&#34;&gt;Retrieve data with SELECT&lt;/h2&gt;

&lt;p&gt;SQLite supports both basic and advanced features of SELECT statement. The following demonstrates the steps to read data from a database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var sqlite3 = require(&#39;sqlite3&#39;).verbose();
// open the database at the given file name
var db = new sqlite3.Database(&amp;quot;todo.sqlite&amp;quot;);

// retrieve result set 1 row at a time
db.each(&amp;quot;SELECT * FROM task&amp;quot;, function(err, row) {
  if (err) throw err;
  console.log(row.due + &amp;quot;: &amp;quot; + row.what);
});

// retrieve complete result set in an array of rows
db.all(&amp;quot;SELECT * from task&amp;quot;, function(err, rows) {
  if (err) throw err;
  console.dir(rows);
})

// close the database
db.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After importing the module &lt;code&gt;sqlite3&lt;/code&gt;, specify the file name of the database and open it with the constructor &lt;code&gt;sqlite3.Database()&lt;/code&gt;.  Use the methods &lt;code&gt;db.each()&lt;/code&gt; or &lt;code&gt;db.all()&lt;/code&gt; to run a SELECT query. The callback to these methods have two parameters (similar to file I/O functions is &lt;code&gt;fs&lt;/code&gt;). The first parameter is error. If the error is &lt;code&gt;null&lt;/code&gt;, the SQL runs successfully, and the result is available in the second parameter.&lt;/p&gt;

&lt;p&gt;The first method &lt;code&gt;db.each()&lt;/code&gt; returns the result set row by row. Each row is represented by a JavaScript object, with one property for each column.  This is suitable for reading data from a large result set.&lt;/p&gt;

&lt;p&gt;The second method &lt;code&gt;db.all()&lt;/code&gt; returns the complete result set in an array &lt;code&gt;rows&lt;/code&gt;. This is more convenient, and easier to use for relatively small result set.&lt;/p&gt;

&lt;p&gt;You might notice that we use the &lt;code&gt;function&lt;/code&gt; expression in callback. This is required because &lt;code&gt;sqlite3&lt;/code&gt; uses the &lt;code&gt;this&lt;/code&gt; keyword for result in UPDATE, DELETE and INSERT. For consistency, we&amp;rsquo;ll use &lt;code&gt;function&lt;/code&gt; expression instead of arrow functions in all callbacks for our SQLite examples.&lt;/p&gt;

&lt;h2 id=&#34;placeholders&#34;&gt;Placeholders&lt;/h2&gt;

&lt;p&gt;You can supply parameters to fill in placeholders in SQL statements in &lt;code&gt;sqlite3&lt;/code&gt;. This is especially useful because the module will perform suitable quoting for string. Please refer to &lt;a href=&#34;https://github.com/mapbox/node-sqlite3/wiki/API&#34;&gt;online reference&lt;/a&gt; for more ways to use placeholders.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// show due date and task description for completed tasks in the study category
db.each(&amp;quot;SELECT due, what FROM task WHERE done=? AND category=?&amp;quot;,
  [1, &#39;study&#39;],
  function(err, row) {
    if (err) throw err;
    console.log(row.due + &amp;quot;: &amp;quot; + row.what);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert-update-and-delete&#34;&gt;INSERT, UPDATE and DELETE&lt;/h2&gt;

&lt;p&gt;Use the method &lt;code&gt;db.run()&lt;/code&gt; to execute INSERT, UPDATE and DELETE statements. In the callback to this method, the property &lt;code&gt;this.changes&lt;/code&gt; indicates the number of rows affected by the query, and the property &lt;code&gt;this.lastID&lt;/code&gt; contains the value of the last inserted row ID.  (That is the INTEGER PRIMARY KEY in our table. Refer to this for &lt;a href=&#34;https://www.sqlite.org/autoinc.html&#34;&gt;more info&lt;/a&gt;.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;db.run(&#39;INSERT INTO task (due, what, category, done) VALUES (?,?,?,?)&#39;,
  [ &#39;2016-11-11&#39;, &#39;comp312 test&#39;, &#39;study&#39;, 0 ],
  function(err) {
    if (err) throw err;
    console.log(&#39;id of the new row = &#39;, this.lastID);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next is an example of DELETE.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// delete all completed tasks
db.run(&#39;DELETE FROM task WHERE done=1&#39;,
  function(err) {
    if (err) throw err;
    console.log(&#39;Number of rows deleted = &#39;, this.changes);
  }
);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>